# Debug Containerized Applications in Kubernetes Pods

Kubernetes (K8s) is an open-source container orchestration tool that manages containerized applications in various deployment environments. To deploy, run, and manage Kubernetes in a cloud-native environment, the cloud service providers have been using managed Kubernetes services such as Amazon Elastic Kubernetes Service (EKS), Microsoft Azure Kubernetes Service, Google Kubernetes Engine (GKE). 

The basic architecture of Kubernetes consists of a master node and a worker node. The master node manages the Kubernetes cluster and the worker node runs the containerized applications. The Kubernetes API server is the entry point to the Kubernetes cluster and the client can interact with the API server through User Interface (UI), Application Programming Interface (API), and Command Line Interface(CLI). The worker nodes perform all the tasks assigned by the master node.

`kubectl` is the CLI used by the client to interact with the Kubernetes cluster. The `kubectl` CLI communicates with the Kubernetes API server. In Kubernetes, a pod is an abstraction over the containerized application.

Kubernetes contains several commands, if the application is not behaving properly in the pod, then the client can use the following commands for debugging the Kubernetes pod:

## Use `kubectl get pods` to check the pods status

`kubectl get` command will show one or multiple resources. Use `kubectl get pods` command to see a list of all the available pods along with their status. 

To check the status of all the pods with extra information such as the name of the node, run the following command 

```shell
kubectl get pods -o wide
```
Use the following command to list all the pods running in a specific namespace.  

```shell
kubectl get pods --namespace=[namespace_name]
```

## Use `kubectl describe pods` to obtain the pods details

Use the following command to check the latest events and the current status of the pod.

```shell
kubectl describe pods ${POD_NAME}
```

Check whether all the pods are `Running` or they are just recently restarted. Based on the state of the pods, continue the debugging.

If the state of the pod is `Pending`, it indicates that the pod is not scheduled on the node. This happens due to insufficient resources. Check the output of the `kubectl describe...` command. You can see the message from the scheduler and the reason behind not scheduling the pod.

For example, if the event generated by the scheduler indicates the reason for failing to schedule the pod as `FailedScheduling` and the message shows that enough resources are not available on any other worker node, then use the `kubectl scale` command and specify four or fewer replicas.

If the state of the pod is `Waiting`, it indicates that the pod is scheduled on the node, but was unable to run on the worker node. The output of the `kubectl describe...` command will be helpful in this situation. Most of the time, the reason for the `Waiting` pod will be a failure in pulling the image. To resolve this issue, perform the following tasks:

1. Crosscheck the name of the image
1. Check whether you have pushed the image to the registry
1. Check whether the image can be pulled manually.

Besides `kubectl describe pod` and `kubectl get pod` commands, if you need extra information about the pod, then pass `-o yaml` output format flag to `kubectl get pod`. It will provide all the information about the pod in YAML format. 

## Use `kubectl logs` to debug a container in the pod

 `kubectl logs` is an important command for debugging the Kubernetes pod. This command shows the log information about the container in the pod or any particular resource. Use this command to review logs or debug a container.

Use `kubectl exec` to debug a container from inside in the pod

Use the `kubectl exec` command to debug a container from inside or to explore the environment of the container.

If the container image has debugging utilities (images built from Windows and Linux OS base image), then you can execute `kubectl exec` inside a particular container. Use `-i` and `-t` arguments along with `kubectl exec` for an interactive terminal.

```
Kubectl exec -it [pod name] -- bin/bash
```

If the container image does not have a shell or the application crashes as soon as it starts, then utilize the `kubectl debug` command. This command is used for creating a clone of a pod that will aid in debugging.

Execute the following command for creating a copy of `qhkapp` named `qhkapp-debug`, which will add a new Ubuntu container for debugging.

```
kubectl debug qhkapp -it --image=ubuntu --share-processes --copy-to=qhkapp-debug
Defaulting debug container name to debugger-w7xmf.
If you don't see a command prompt, try pressing enter.
root@myapp-debug:/#
```
**Note:** After finishing the task, delete the debugging pod.

We recommend that you can start the debugging of the containerized application in the Kubernetes pods by running the `kubectl get pods` command, then use the `kubectl logs` command. If the issue is not fixed, then use the `kubectl exec` command to explore the container from inside and check the containerâ€™s entire file system and the environmental variables, review the configurations, etc.

# References

1. https://kubernetes.io/docs/concepts/overview/
1. https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands
1. https://docs.oracle.com/en/operating-systems/olcne/1.1/orchestration/worker.
1. https://kubernetes.io/docs/tasks/debug/debug-application/debug-running-pod/
1. https://kubernetes.io/docs/tasks/debug/debug-application/debug-pods/
1. https://kubernetes.io/docs/tasks/debug/debug-application/get-shell-running-container/
1. https://www.containiq.com/post/using-kubectl-exec-shell-commands-examples
